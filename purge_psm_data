#! /bin/ksh
#----------------------------------------------------------------------------------
#  File:  nb_purge_psm_data.ksh
#
#  Desc:  UNIX shell script to Call respective Fuctions of  Package nb_purge_psm_data  
#-------------------------------------------------------------------------------------
pgmName=`basename $0`
pgmName=${pgmName##*/}    # remove the path
pgmExt=${pgmName##*.}     # get the extension
pgmName=${pgmName%.*}     # get the program name
pgmPID=$$                 # get the process ID
exeDate=`date +"%h_%d"`   # get the execution date
LOGFILE="${LOGDIR}/$exeDate.log"
ERRORFILE="${ERROR}/err.$pgmName."$exeDate
ERRINDFILE=err.ind

# Initialize number of parallel threads
OK=0
FATAL=255

USAGE="Usage: `basename $0`  <connect> \n"

#-------------------------------------------------------------------------
# Function Name: LOG_ERROR
# Purpose      : Log the error messages to the error file.
#-------------------------------------------------------------------------
function LOG_ERROR
{
   errMsg=`echo $1`       # echo message to a single line
   errFunc=$2
   retCode=$3

   dtStamp=`date +"%G%m%d%H%M%S"`
   echo "$pgmName~$dtStamp~$errFunc~$errMsg" >> $ERRORFILE
   if [[ $retCode -eq ${FATAL} ]]; then
      LOG_MESSAGE "Aborted in" $errFunc $retCode
   fi
   return $retCode
}

#-------------------------------------------------------------------------
# Function Name: LOG_MESSAGE
# Purpose      : Log the  messages to the log file.
#-------------------------------------------------------------------------
function LOG_MESSAGE
{
   logMsg=`echo $1`       # echo message to a single line
   logFunc=$2
   retCode=$3

   dtStamp=`date +"%a %b %e %T"`
   echo "$dtStamp Program: $pgmName: PID=$pgmPID: $logMsg $logFunc" >> $LOGFILE
   return $retCode
}

#-------------------------------------------------------------------------
# Function Name: EXEC_SQL
# Purpose      : Used for executing the sql statements.
#-------------------------------------------------------------------------

function EXEC_SQL
{
   sqlTxt=$*

   sqlReturn=`echo "set feedback off;
      set heading off;
      set term off;
      set verify off;
      set serveroutput on size 1000000;

      VARIABLE GV_return_code    NUMBER;
      VARIABLE GV_script_error   CHAR(255);

      EXEC :GV_return_code  := 0;
      EXEC :GV_script_error := NULL;

      WHENEVER SQLERROR EXIT ${FATAL}
      $sqlTxt
      /

      print :GV_script_error;
      exit  :GV_return_code;
      " | sqlplus -s ${CONNECT}`
    
   if [[ $? -ne ${OK} ]]; then
      LOG_ERROR "${sqlReturn}" "EXEC_SQL" ${FATAL} ${ERRORFILE} ${LOGFILE} ${pgmName}
      return ${FATAL}
   fi

   return ${OK}
}


#-------------------------------------------------------------------------
# Function Name: DEL_TRANSFERS
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_TRANSFERS.
#-------------------------------------------------------------------------

function DEL_TRANSFERS
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_TRANSFERS(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_TRANSFERS Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}

#-------------------------------------------------------------------------
# Function Name: DEL_DSDS
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_DSDS.
#-------------------------------------------------------------------------

function DEL_DSDS
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_DSDS(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_DSDS Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}

#-------------------------------------------------------------------------
# Function Name: DEL_RTVS
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_RTVS.
#-------------------------------------------------------------------------

function DEL_RTVS
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_RTVS(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_RTVS Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}

#-------------------------------------------------------------------------
# Function Name: DEL_INV_ADJUSTS
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_INV_ADJUSTS.
#-------------------------------------------------------------------------

function DEL_INV_ADJUSTS
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_INV_ADJUSTS(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_INV_ADJUSTS Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}

#-------------------------------------------------------------------------
# Function Name: DEL_STOCK_COUNTS
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_STOCK_COUNTS.
#-------------------------------------------------------------------------

function DEL_STOCK_COUNTS
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_STOCK_COUNTS(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_STOCK_COUNTS Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}

#-------------------------------------------------------------------------
# Function Name: DEL_ITEMS
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_ITEMS.
#-------------------------------------------------------------------------

function DEL_ITEMS
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_ITEMS(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_ITEMS Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}

#-------------------------------------------------------------------------
# Function Name: DEL_SALES
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_SALES.
#-------------------------------------------------------------------------

function DEL_SALES
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_SALES(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_SALES Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}
#-------------------------------------------------------------------------
# Function Name: DEL_ERROR_LOG
# Purpose      : calls the package NB_PSM_PURGE_DATA_SQL.DEL_ERROR_LOG.
#-------------------------------------------------------------------------

function DEL_ERROR_LOG
{
   threadVal=1
   sqlTxt="
      DECLARE
         L_str_error_tst   VARCHAR2(1) := NULL;

         FUNCTION_ERROR    EXCEPTION;
      BEGIN

         if NOT NB_PSM_PURGE_DATA_SQL.DEL_ERROR_LOG(:GV_script_error) then
            raise FUNCTION_ERROR;
         end if;

         COMMIT;

      EXCEPTION
         when FUNCTION_ERROR then
            ROLLBACK;
            :GV_return_code := ${FATAL};
         when OTHERS then
            ROLLBACK;
            :GV_script_error := SQLERRM;
            :GV_return_code := ${FATAL};
      END;"	  
   EXEC_SQL ${sqlTxt}

   if [[ $? -ne ${OK} ]]; then
      echo "DEL_ERROR_LOG Thread: $threadVal Failed" >>${ERRORFILE}
      return ${FATAL}
   else
      LOG_MESSAGE "Thread ${threadVal} - Successfully Completed"
      return ${OK}
   fi
}
#-----------------------------------------------
# Main program starts 
# Parse the command line
#-----------------------------------------------

# Test for the number of input arguments
if [ $# -lt 2 ]
then
   echo $USAGE
   exit 1
fi

CONNECT=$1
JOBNAME=$2

USER=${CONNECT%/*}


echo "Process Started..." >>$ERRORFILE

$ORACLE_HOME/bin/sqlplus -s $CONNECT <<EOF >>$ERRORFILE
EOF

if [ `cat $ERRORFILE | grep "ORA" | wc -l` -gt 1 ]
then
   echo "Exiting due to ORA/LOGIN Error. Check error file"  >> $LOGFILE
   exit 1;
fi

LOG_MESSAGE "Started by ${USER}"
#Calls to the fucntion based on the thread count

if [ $JOBNAME = "tsfs" -o $JOBNAME = "all" ]
then
	DEL_TRANSFERS
	echo "Del_Transfers OK"  >> $LOGFILE
fi

if [ $JOBNAME = "dsds" -o $JOBNAME = "all" ]
   then
	DEL_DSDS
    echo "Del_Dsds OK"  >> $LOGFILE
fi

if [ $JOBNAME = "rtvs" -o $JOBNAME = "all" ]
   then
	DEL_RTVS
    echo "Del_Rtvs OK"  >> $LOGFILE
fi

if [ $JOBNAME = "inv_adj" -o $JOBNAME = "all" ]
   then
	DEL_INV_ADJUSTS
    echo "Del_inv_adjusts OK"  >> $LOGFILE
fi

if [ $JOBNAME = "stock_count" -o $JOBNAME = "all" ]
   then
	DEL_STOCK_COUNTS
    echo "Del_Stock_counts OK"  >> $LOGFILE
fi

if [ $JOBNAME = "items" -o $JOBNAME = "all" ]
   then
	DEL_ITEMS
    echo "Del_Items OK"  >> $LOGFILE
fi

if [ $JOBNAME = "sales" -o $JOBNAME = "all" ]
   then
	DEL_SALES
    echo "Del_Sales OK"  >> $LOGFILE
fi

if [ $JOBNAME = "sales" -o $JOBNAME = "all" ]
   then
	DEL_ERROR_LOG
    echo "Del_error_LOG OK"  >> $LOGFILE
fi
	
# Check for any Oracle errors from the SQLPLUS process
if [ `grep "ORA-" $ERRORFILE | wc -l` -gt 0 ]
then
   echo "Exiting due to ORA Error. Check error file"  >> $LOGFILE
   exit 1
else
   rm -f $ERRORFILE
fi

exit 0
